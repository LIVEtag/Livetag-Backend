Docker
======
Определения:

- [**Image**](https://docs.docker.com/engine/reference/commandline/images/) - это образ который содержит в себе уже заготовленный набор инструментов необходимый для запуска окружения. (php-apache, MySql и т.д.)
- **Сontainer** - контейнер собирается из образа. Каждый контейнер является независимой платформой. Контейнеры можно линковать,
т.е. объединять работу нескольких конейнеров между собой. К примеру слинковать PHP с MySql тем самым предоставив конейнеру c PHP доступ к БД.
- **Deamon** - программа работающая в фоновом режимме без участия пользоватаеля.

> Docker - это своего рода демон который позволят управлять образами и запускать контейнеры.

Плюсы:
- Основной его плюс в том что нет необходимости каждый раз заного настраивать окружение локально или на сервере,
вы просто запускаете образ где уже все готово для работы.
- Образ может содержать только необходимые компоненты не нагружая систему лишним, что делает его работу быстрой и продуктивной.
- Позволяет легко манипулировать контейнерами не нарушая целостность и работоспособность других.
- Простота переноса и разворачивание платформы на любой машине/облаке/сервере.
- Наличие огромного хранилища [DockerHub](https://hub.docker.com/) где доступно множество готовых образов.

Сборка нового образа:

Есть два пути создания образа. Можно сделать образ с нуля или создать новый на основании существующего.
Создание образа чем-то схоже с созданием GIT репозитория.
Вы создаете образ, добавляете в него новые файлы, комитите изменения, пушите на DockerHub или в другие хранилища образов.
Или используя файл Docker вы указывате образ из которого хотите собрать свой и дополняете его необходимыми коммпонентами или инструкциями.


Запуск образа
======
**Самый простой пример запуска образа:**

```
docker run -p 3306:3306 mysql:5.7
```

Первым шагом docker будет искать локально наличие образа mysql. Если его не будет, он его скачает с DockerHub.
Далее запуститься демон с mysql на 3306 порту. После успешного запуска саму БД уже можно использовать и работать с ней.
Замете, все это выполнив всего лишь одну команду из консоли.

**Второй вариант запуска:**

Создав файл Docker в нем можно указать образ на основании которого вы хотите создать свой.
Подключить к нему разделы. Установить доп. пакеты.
Выполнить настройку внутри контейнера и т.д.
Важно понимать что при сборке собственного образа во время первого запуска докер выполнит все инструкции описанные в файле `Docker` и сохранит его локально.  
Этот процесс можно запустить самостоятельно используя [команду](https://docs.docker.com/engine/reference/commandline/build/) `docker build`.
Если же такой образ собраный уже есть локально, то он просто возмет его и запустит без этапа сборки.

Пример файла `Docker`:
```
#название образа на основании которого будет создан текущий
FROM hub.ci.gbksoft.net:5000/pub/php-apache:7.1

#команда run позволяет выполнять инструкции во время сборки образа
RUN apt-get update && apt-get install -y curl

#команда выполняемая во время запуска контейнера
CMD ["apache2-foreground"]

#Инструкция VOLUME добавляет тома в образ
VOLUME ["/code"]

#Команд много, возможностей много, за деталями лучше обратиться в документацию
```


Docker compose
======
Это [инструмент](https://docs.docker.com/compose/overview/) который позволяет запускать "multi-container Docker applications".
Т.е. используя только один файл конфигурации в формате `YAML` мы можешем связать между собой несколько контейнеров,
задать им пармаметры и манипулировать ими в дальнейшем.
Это удобно и позвоялет ускорить многие процессы, а также оптимизировать их.

### Запуск:

- В первую очередь вам необходимо подготовить или сбилдить образы которые вы хотите использовать.
- Далее необходимо добавить контейнеры и задать им параметры используя файл docker-compose.yml.

Пример `docker-compose.yml` файла:

```
version: '3.3'
services:
  web-php:
    image: hub.ci.gbksoft.net:5000/pub/php-apache:7.1
    volumes:
      - ./code:/app:rw
    ports:
     - "80:80"
  db:
    image: mysql:5.7
  ports:
    - "${DB_PORT}:3306"
```

- в заключении выполняем команду `docker-compose up` и запускаем наше приложение.

> Для последующих запусков необходимо использовать команды `docker-compose start\stop`. Команда `up` включает в себя этапы: builds, (re)creates, starts and attaches. 
Если вы вносили изменения или устанавливали доп. пакеты в контейнере, то команда `up` удалит все ваши труды.

### Сервисы

Сервисы позволяют нам манипулировать контейнерами, задавать им параметры
(открытие портов, подключение разделов, подключение контейнеров между собой и прочее).
Еще одно удобство заключается в том что все собрано в 1 файле, что упрощает работу с контейнерами в разы.
В примере ниже мы можем видеть несколько сервисов которые подключены в `YML` файле, а именно web и db.
```
version: '3.3'
services:
  web-php:
    image: hub.ci.gbksoft.net:5000/pub/php-apache:7.1
    ports:
      - "80:80"
      - "443:443"
    links:
      - db
  db:
    image: mysql:5.7
    ports:
      - "${DB_PORT}:3306"
    volumes:
      - ./dev/docker/mysql/5.7/data:/var/lib/mysql
```
Преймущества в таком подходе в том что мы можем изолировать сервисы друг от друга,
или же линковать между собой открываая доступ и другие возможности для взаимодействия.
Самый простой пример это когда у нас есть web проект и ему необходимо взаимодействовать с db.
В таком случае мы линкуем между собой web-php и db. Делать это можно как в `YML` файле так и используя параметры в CLI.

### Переменные окружения .env

Compose поддерживает переменные окружения используя файл `.env` который находится рядом в папке.
В самом файле мы объявляем перменные в формате `VAR=VAL`.
Каждая перменная должна находится на новой строке.
Строки начинающиеся с `;` являются комментариями.

Также переменные окружения можно передать указав в файле конфигурации строки:
```
db:
  image: mysql:5.7
  environment:
    MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
    MYSQL_ROOT_HOST: ${DB_HOST}
    MYSQL_DATABASE: ${DB_NAME}
    MYSQL_USER: ${DB_USERNAME}
    MYSQL_PASSWORD: ${DB_PASSWORD}
```
Еще можно передать переменные во время запуска контейнера используя параметр `--env-file=FILE` для файла
и `-e MYSQL_PASSWORD=root` для конкретной переменной.


### CLI - полезные команды для докера

- `docker ps -a` - просмотр информации о состоянии контейнеров
- `docker images` - список образов
- `docker exec -it {container_id|container_name} bash` - позволяет зайти в контейнер и вполнять внутри консольные команды
- `docker rm {container_id|container_name}` - удалить контейнер
- `docker rmi {image_id|repository:tag}` - удалить образ
- `docker inspect {container_id|container_name}` - информация о контейнере


Gitlab CI/CD
======
Gitlab это инструмент который позволяет автоматизировать большую часть процессов связанных с разработкой.
Неотъемлемой частью Gitlab является поддержка непрерывной интеграции,
непрерывного развертывания и непрерывной доставки для создания, тестирования и развертывания вашего приложения.
А теперь немного подробнее.
Сам проект мы можем без проблем поднять локально используя `docker-compose` и работать с ним из IDE в режиме реального времени.
Но если нам необходимо поднять проект так как это происходит на сервере, пройдя все фазы сборки, тестирования, запуска,
получение ссылки доступной из мира, то для этого необходимо использовать Gitlab Runner.
Как это устроено? Gitlab сначала проходит все инструкции описанные в файле `.gitlab-ci.yml`.
Там он выполнит build, проведет тесты, соберет артефакты. Далее проект будет готов для запуска.  
Вы инициализируете запук и ваш раннер начнет выполнять поднятие проекта локально на вашей машине создавая необходимые контейнеры и выполняя инструкции внтури контейнера.
Т.е. контейнеры и код внутри него лежат у вас локально, а Gitlab выполняет всю работу по разворачиванию его на вашей машине.
Далее используя vpn-proxy мы можем увидеть наш проект из мира открыв его по ссылке.

### Поднятие проекта используя Gitlab Runner:

1. Клоним себе проект `git clone git@gitlab.gbksoft.net:dev-department/php-yii2-base-template.git`

2. Заполняем переменные окружения. Открываем Gitlab, заходим в проект -> Settings -> CI/CD -> Secret variables.
Список необходимых переменных можно взять в файле `.env.example` из корня проекта.
`MAIN_HOST` Должен соотвествовать вашей личной ссылке, т.к. вы не можете выбрать себе ссылку сами.
Ссылка формируется автоматически при запуске проекта.
Пример ссылки: https://second_name-io-local.ci.gbksoft.net/.
Желательно не использовать пользовател БД как root иначе могут возникнуть конфликты. В целом лучше использовать уникальное имя.

3. Теперь необходимо установать раннер. Для этого можно воспользоваться инструкцией на [официальном сайте](https://docs.gitlab.com/runner/install/linux-manually.html).
Команда для установки в системе GNU/Linux:
```
# Linux x86-64
sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64
```
И дать ему права на выполнение:
```
sudo chmod +x /usr/local/bin/gitlab-runner
```

4. Далее необходимо проверить alias для БД в файле `.gitlab-ci.yml`. Если вы задаете `DB_HOST` как "mysql", то и alias должен быть соотвествующим.

5. Теперь необходимо зарегестрировать раннер в системе и запустить его.  
Для этого можно воспользоваться исчерпывающей [инструкцией](https://wiki.gbksoft.net/admin:gitlab:runner-local).

6. Run Pipeline. Заходим в проект -> CI/CD -> Pipelines. Находим успешню сборку и запускаем ее (у нее должна быть кнопка run в конце).
Если сборок нету, нужно нажать Run Pipeline что бы собрать новую.
Иногда возникают проблемы с запуском старых сборок, поэтому когда эти проблемы возникают, необходимо создать новую сборку.
Не все Pipeline имеют кнопку run. Это зависит от настроек в файле `.gitlab-ci.yml`. Для каждого окружения прописан параметр `only`.
Это параметр указывает на то для какой ветки гита будет запущено данное окружение.
Т.е. чтобы запустить pipline для dev окружения нужно запушить ветку `develop`.

7. Настройка локального VPN по [инструкци](https://wiki.gbksoft.net/admin:gitlab:vpn) в wiki.
Это необходимо для того чтобы локальный проект был доступен из мира. Больше информации [тут](https://wiki.gbksoft.net/admin:gitlab:vpn-proxy).
Возможно админы не дали доступ к VPN, если вам не удается подключится, обратитесь к ним.
На вашем клиентском ПК должен быть настроен процесс автоматической настройки портов.
По дефолту у вас это уже должно быть настроено админами. Подробнее [тут](https://wiki.gbksoft.net/admin:gitlab:vpn-proxy#%D0%BD%D0%B0_%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%B5_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%B0)
Ссылка на сервере должна подтянутся после подключения VPN в течении 15 секунд. Если вознинкли трудности, то в первую очередь попробуйте переподключить VPN.

8. И так, если у вас все настроено, нет проблем с VPN, и все запущено, то вы можете открыть свой проект используя свою ссылку.

Ссылки:
- Полезная [статья](https://wiki.gbksoft.net/admin:gitlab:tricks) для некоторых весьма полезных доп. фич и шаблонов которые можно использовать в файле `.gitlab-cy.yml`.
- Еще одна [статья](https://wiki.gbksoft.net/admin:gitlab:gitlab-ci.yml) где подробно можно прочесть о файле `.gitlab-cy.yml`.

PS: В чем же сокральный смысл?
1) Данная фича позволяет вывести ваш web проект в мир и он станет доступным с любого устройства. 
Благодаря этому можно настроить любые сервисы которые требуют обратной связи, к примеру платежи с webhook.
Открыть проект на мобильных устройствах и планшетах для проверки верстки и пр. 
2) Запущенный контейнер находится у вас на PC. Это хорошо для случаев когда вам нужен прямой доступ к нему.
3) Процесс деплоя происходит у вас на PC, тем самым вы можете самостоятельно отследить все процессы и манипулировать ими.
4) Редактировать файлы проекта и иметь к ним доступ даже через IDE.

### Добавление новых сервисов

Сервисы нужны для того чтобы прилинковать к основному контейнеру дополнительные, к примеру БД.
Пример подключения:
```
services:
    - name: mysql:5.7
      alias: mysql
      command: ["--character-set-server=utf8mb4", "--collation-server=utf8mb4_unicode_ci"]
```

### Добавление новых задач
С помощью Gitlab можно добавлять задачи которые буду выполнятся во время добавления новых коммитов. 
Сами задачи могут быть объедены в "stage" и выполнятся паралельно что ускоряет прохождение всех этапов. 
Задачи могуть быть разные, к примеру запуск статического анализа кода, запуск тестов и т.д.

Пример задачи:
```
phpmd:
  stage: tests
  image:
    name: hub.ci.gbksoft.net:5000/pub/php-apache:7.1
    entrypoint: [""]
  artifacts:
    untracked: true
    paths:
      - dev/build/
    when: on_failure
    expire_in: 2h
  script:
    - echo "===== Run tests ====="
    - vendor/bin/dep tests:php_cs
  when: always
  dependencies:
    - build_vendor
  tags:
    - shared_cli
```

- stage: для объедения и запуска задач паралельно.
- script: список команд которые будут выполнены в рамках задачи.
- dependencies: зависимость от других задач
- tags: тут мы указываем тег раннеров на которые мы назначаем задачи

По поводу тегов остановимся подробнее. 
`Gitlab -> Settings -> CI/CD -> Runners settings -> Shared Runners` 
перейдя по этому путимы сможем увидить список доступных раннеров и их тегов для нашего проекта.

Назначение тегов:
- shared-web: тег который используется для запуска окружения
- shared-cli: тег который используется для запуска задач выполняемых из консоли
- shared-namespace: назначение схоже с тегом web, но он необходим для того чтобы решить конфликт во время получении ссылки для форкнутых репозиториев

Мы можем использовать одинаковый тег раннера для нескольких задач. 
В пределах одного раннера может запускатся много задач испольуя многопоточность.

### Deployer

Во время запуска окружения выполняется команда `./vendor/bin/dep gitlab:deploy`.
Подробнее о самом деплоере можно почитать [тут](https://deployer.org/docs). 
В корне проекта есть файл `deplloy.php` где описан весь список задач выполняемых деплоером. 

Некоторые из них:
- deploy:version - создает файл version.txt который содержит версию текущего коммита.
- tests:php_md/php_cpd/php_cs - Запускает статический анализ кода
- deploy:composer - установка пакетов composer
- deploy:init - инициализация окружения с помощью команды `php init` 
- deploy:run_migrations - запуск миграций


Сode tests
======
Вы можете проверить свой код на наличие допущеных ошибок в стандартах написания кода используя команду `./vendor/bin/dep tests`.
Запустив данную команду вы можете проверить свой код на наличие соотвествий стандартов написания кода.
- php_md: Позволяет обнаружить возможные ошибки, сложные конструкции, не используемые свойства\методы и пр.
- php_cpd: Позволяет обнаружить дублированный код
- php_cs: Позволяет проверить код на соотвестиве стандартам PSR-1, PSR-2 и т.д.

После запуска формируются файлы с отчетами в каталоге `/dev/build/`. В этих файлах можно просмотреть все ошибки и их описание.


Cron
======
В корне проекта присутствует файл `.cron`. 
В него вы можете добавлять нужные для вас cron задачи.
В файле `deploy.php` создан task который запускает крон во время деплоя.


Supervisord
======
Когда вам необходимо запустить в фоновом режиме какой-то процесс, то эта утилитам вам в этом поможет.
За более подробной информацией можно обратиться в нашу [wiki](https://wiki.gbksoft.net/admin:server:supervisord)


DB Adminer
======
Бывают случаи когда вам необходимо получить доступ к БД на сервере запущенном через Gitlab.
Для этого вы можете использовать общедоступный для всех контейнеров [админер](https://adminer.ci.gbksoft.net).
Для доступа необходимо знать IP адрес DB контейнер который вы можете узнать во время деплоя добавив в файл gitlab-ci.yml команду.
Подбробнее про команды можно прочесть [тут](https://wiki.gbksoft.net/admin:gitlab:tricks).
Доступы к БД вы указываете самостоятельно через раздел Variables в Gitlab.

Настройка XDebug в PHPStorm для локальной работы
======
- В браузере можно добавить расширение `Xdebug helper`. 
Оно будет автоматически добавять ко всем запросам необходимые заголовки которые необходимы для соединения.
- В IDE в разделе Debug поменять значение Debug port в соотвествии с тем какое значение вы установили в проекте.
(см. файл docker-compose.yml)
- В разделе Servers добавить новый сервер установить значение host в соотвествии с вашим доменом и отметить галкой Use path mappings.
Там же в колонке Absolute path on server на против строки с путем корня проекта указать значение `/var/www/html`. 
- В разделе DBGp Proxy установить порт в соотвествии с тем какое значение вы установили в проекте.
- Далее в вверхнем меню выбираем Run -> Edit configurations. Добавить `PHP Remote Debug` нажав на +.
Тут же выбрать настроеный вами ранее сервер, установить IDE key: PHPSTORM и отметить галку Filter debug connection by IDE key.
- В файле docker-compose.yml необходимо установить значения IP своей машины для переменной remote_host.

Все настройки произведены, осталось запустить debug:
- Меню Run -> Debug.
- Меню Run -> Start Listening for PHP Debug connections
- Находим нужный файл для дебага, ставим точку остановки и открываем необходимую вам страницу.

PS: Чтобы новые настройки докера применились необходимо перезапустить контейнер. 
