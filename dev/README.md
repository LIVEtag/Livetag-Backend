Docker
======
Определения:

- [**Image**](https://docs.docker.com/engine/reference/commandline/images/) - это образ который содержит в себе уже заготовленный набор инструментов необходимый для запуска окружения. (php-apache, MySql и т.д.)
- **Сontainer** - контейнер собирается из образа. Каждый контейнер является независимой платформой. Контейнеры можно линковать,
т.е. объединять работу нескольких конейнеров между собой. К примеру слинковать PHP с MySql тем самым предоставив конейнеру c PHP доступ к БД.
- **Deamon** - программа работающая в фоновом режимме без участия пользоватаеля.

> Docker - это своего рода демон который позволят управлять образами и запускать контейнеры.

Плюсы:
- Основной его плюс в том что нет необходимости каждый раз заного настраивать окружение локально или на сервере,
вы просто запускаете образ где уже все готово для работы.
- Образ может содержать только необходимые компоненты не нагружая систему лишним, что делает его работу быстрой и продуктивной.
- Позволяет легко манипулировать контейнерами не нарушая целостность и работоспособность других.
- Простота переноса и разворачивание платформы на любой машине/облаке/сервере.
- Наличие огромного хранилища [DockerHub](https://hub.docker.com/) где доступно множество готовых образов.

Сборка нового образа:

Есть два пути создания образа. Можно сделать образ с нуля или создать новый на основании существующего.
Создание образа чем-то схоже с созданием GIT репозитория. 
Вы создаете образ, добавляете в него новые файлы, комитите изменения, пушите на DockerHub или в другие хранилища образов.
Или используя файл Docker вы указывате образ из которого хотите собрать свой и дополняете его необходимыми коммпонентами или инструкциями.


Запуск образа
======
**Самый простой пример запуска образа:**

`docker run -p 3306:3306 mysql:5.7`

Первым шагом docker будет искать локально наличие образа mysql. Если его не будет, он его скачает с DockerHub.
Далее запуститься демон с mysql на 3306 порту. После успешного запуска саму БД уже можно использовать и работать с ней.
Замете, все это выполнив всего лишь одну команду из консоли.

**Второй вариант запуска:**

Создав файл Docker в нем можно указать образ на основании которого вы хотите создать свой.
Подключить к нему разделы. Установить доп. пакеты.
Выполнить настройку внутри контейнера и т.д.
Важно понимать что при сборке собственного образа во время первого запуска докер выполнит все инструкции описанные в файле `Docker` и сохранит его локально.
Этот процесс можно запустить самостоятельно используя [команду](https://docs.docker.com/engine/reference/commandline/build/) `docker build`.
Если же такой образ собраный уже есть локально, то он просто возмет его и запустит без этапа сборки.

Пример файда `Docker`:
```
#название образа на основании которого будет создан текущий
FROM hub.ci.gbksoft.net:5000/pub/php-apache:7.1

#команда run позволяет выполнять инструкции во время сборки образа
RUN apt-get update && apt-get install -y curl

#команда выполняемая во время запуска контейнера
CMD ["apache2-foreground"]

#Инструкция VOLUME добавляет тома в образ
VOLUME ["/code"]

#Команд много, возможностей много, за деталями лучше обратиться в документацию
```


Docker compose
======
Это [инструмент](https://docs.docker.com/compose/overview/) который позволяет запускать "multi-container Docker applications".
Т.е. используя только один файл конфигурации в формате `YAML` мы можешем связать между собой несколько контейнеров,
задать им пармаметры и манипулировать ими в дальнейшем.
Это удобно и позвоялет ускорить многие процессы, а также оптимизировать их.

###Запуск:

- В первую очередь вам необходимо подготовить или сбилдить образы которые вы хотите использовать.
- Далее необходимо добавить контейнеры и задать им параметры используя файл docker-compose.yml.

Пример `docker-compose.yml` файла:

```
version: '3.3'
services:
  web-php:
    image: hub.ci.gbksoft.net:5000/pub/php-apache:7.1
    volumes:
      - ./code:/app:rw
    ports:
     - "80:80"
  db:
    image: mysql:5.7
  ports:
    - "${DB_PORT}:3306"
```

- в заключении выполняем команду `docker-compose up` и запускаем наше приложение.

###Сервисы

Сервисы позволяют нам манипулировать контейнерами, задавать им параметры
(открытие портов, подключение разделов, подключение контейнеров между собой и прочее).
Еще одно удоство заключает в том что все собрано в 1 файле, что упрощает работу с контейнерами в разы.
В примере ниже мы можем видеть несколько сервисов которые подключены в `YML` файле, а именно web и db.
```
version: '3.3'
services:
  web-php:
    image: hub.ci.gbksoft.net:5000/pub/php-apache:7.1
    ports:
      - "80:80"
      - "443:443"
    links:
      - db
  db:
    image: mysql:5.7
    ports:
      - "${DB_PORT}:3306"
    volumes:
      - ./dev/docker/mysql/5.7/data:/var/lib/mysql
```
Преймущества в таком подходе в том что мы можем изолировать сервисы друг от друга,
или же линковать между собой открываая доступ и другие возможности для взамодействия.
Самый простой пример это когда у нас есть web проект и ему необходимо взаимодействовать с db.
В таком случае мы линкуем между собой web-php и db. Делать это можно как в `YML` файле так и используя параметры в CLI.

###Переменные окружения .env

Compose поддерживает переменные окружения используя файл `.env` который находится рядом в папке.
В самом файле мы объявляем перменные в формате `VAR=VAL`.
Каждая перменная должна находится на новой строке.
Строки начинающиеся с `;` являются комментариями.

Также переменные окружения можно передать указав в файле конфигурации строки:
```
db:
  image: mysql:5.7
  environment:
    MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
    MYSQL_ROOT_HOST: ${DB_HOST}
    MYSQL_DATABASE: ${DB_NAME}
    MYSQL_USER: ${DB_USERNAME}
    MYSQL_PASSWORD: ${DB_PASSWORD}
```
Еще можно передать переменные во время запуска контейнера используя параметр `--env-file=FILE` для файла
и `-e MYSQL_PASSWORD=root` для конкретной переменной.


###CLI - полезные команды для докера

- `docker ps -a` - просмотр информации о состоянии контейнеров
- `docker images` - список образов
- `docker exec -it {container_id|container_name} bash` - позволяет зайти в контейнер и вполнять внутри консольные команды
- `docker rm {container_id|container_name}` - удалить контейнер
- `docker rmi {image_id|repository:tag}` - удалить образ


Gitlab CI/CD
======
Gitlab это инструмент который позволяет автоматизировать большую часть процессов связанных с разработкой.
Неотъемлемой частью Gitlab является поддержка непрерывной интеграции,
непрерывного развертывания и непрерывной доставки для создания, тестирования и развертывания вашего приложения.
А теперь немного подробнее. 
Сам проект мы можем без проблем поднять локально используя `docker-compose` и работать с ним из IDE в режиме реального времени.
Но если нам необходимо поднять проект так как это происходит на сервере, пройдя все фазы сборки, тестирования, запуска, 
получение ссылки доступной из мира, то для этого необходимо использовать Gitlab Runner.
Как это устроено? Gitlab сначала проходит все инструкции описанные в файле `.gitlab-ci.yml`. 
Там он выполнит build, проведет тесты, соберет артефакты. Далее проект будет готов для запуска. 
Вы инициализируете запук и ваш раннер начнет выполнять поднятие проекта локально на вашей машине создавая необходимые контейнеры и выполняя инструкции внтури контейнера. 
Т.е. контейнеры и код внутри него лежат у вас локально, а Gitlab выполняет всю работу по разворачиванию его на вашей машине. 
Далее используя vpn-proxy мы можем увидеть наш проект из мира открыв его по ссылке.

###Поднятие проекта используя Gitalab Runner:

1. Клоним себе проект `git clone git@gitlab.gbksoft.net:dev-department/php-yii2-base-template.git`

2. Заполнить переменные окружения. Открываем Gitlab, заходим в проект -> Settings -> CI/CD -> Secret variables.
Список необходимых переменных можно взять в файле `.env.example` из корня проекта.
PS: `MAIN_HOST` Должен соотвествовать вашей личной ссылке, т.к. вы не можете выбрать себе ссылку сами. 
Ссылка формируется автоматически при запуске проекта.
Пример ссылки: https://second_name-io-local.ci.gbksoft.net/.

> Желательно не использовать пользовател БД как root иначе могут возникнуть конфликты. В целом лучше использовать уникальное имя.

3. Теперь необходимо установать раннер. Для этого можно воспользоваться инструкцией на [официальном сайте](https://docs.gitlab.com/runner/install/linux-manually.html).
Команда для установки в системе GNU/Linux:
```
# Linux x86-64
sudo wget -O /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64
```
И дать ему права на выполнение:
```
sudo chmod +x /usr/local/bin/gitlab-runner
```

4. Далее необходимо проверить alias для БД в файле `.gitlab-ci.yml`. Если вы задаете `DB_HOST` как "mysql", то и alias должен быть соотвествующим.

5. Теперь необходимо зарегестрировать раннер в системе и запустить его.
Для этого можно воспользоваться исчерпывающей [инструкцией](https://wiki.gbksoft.net/admin:gitlab:runner-local).

6. Run Pipeline. Заходим в проект -> CI/CD -> Pipelines. Находим успешню сборку и запускаем ее (у нее должна быть кнопка run в конце).
Если сборок нету, нужно нажать Run Pipeline что бы собрать новую.
Иногда возникают проблемы с запуском старых сборок, поэтому когда эти проблемы возникают, необходимо создать новую сборку.

> Не все Pipeline имеют кнопку run. Это зависит от настроек в файле `.gitlab-ci.yml`. Для каждого окружения прописан параметр `only`.
Это параметр указывает на то для какой ветки будет запущено данное окружение. 
Т.е. чтобы запустить pipline для dev окружения нужно запушить ветку `develop`.

7. Настройка локального VPN по [инструкци](https://wiki.gbksoft.net/admin:gitlab:vpn) в wiki.
Это необходимо для того чтобы локальный проект был доступен из мира. Больше информации [тут](https://wiki.gbksoft.net/admin:gitlab:vpn-proxy).
Возможно админы не дали доступ к VPN, если вам не удается подключится, обратитесь к ним.
На вашем клиентском ПК должен быть настроен процесс автоматической настройки портов.
По дефолту у вас это уже должно быть настроено админами. Подробнее [тут](https://wiki.gbksoft.net/admin:gitlab:vpn-proxy#%D0%BD%D0%B0_%D1%81%D1%82%D0%BE%D1%80%D0%BE%D0%BD%D0%B5_%D0%BA%D0%BB%D0%B8%D0%B5%D0%BD%D1%82%D0%B0)
Ссылка на сервере должна подтянутся после подключения VPN в течении 15 секунд. Если вознинкли трудности, то в первую очередь попробуйте переподключить VPN.

8. И так, если у вас все настроено, нет проблем с VPN, и все запущено, то вы можете открыть свой проект используя свою ссылку.

Robo
======


Git hook
======
